# Computer Network Chapter 3 Notes

## RDT协议发展

RDT 的目标是在一个**不可靠的信道 (unreliable channel)** 上实现**可靠的数据传输**。不可靠的信道可能具备以下一个或多个特性：

1. **比特差错 (Bit Errors):** 传输过程中，分组中的比特可能会发生翻转。
2. **分组丢失 (Packet Loss):** 整个分组可能在传输过程中丢失，永远不会到达目的地。
3. **分组乱序 (Packet Reordering):** 分组可能不按发送顺序到达目的地（虽然 RDT 3.0 的基本停等协议不涉及乱序，但更高级的 RDT 协议会考虑这一点）。
4. **分组延迟 (Packet Delay):** 分组可能经历不同的传输延迟。

RDT 的演进就是针对这些信道不可靠性的逐步增强协议的能力。我们从最简单、最理想的情况开始。

### **1. RDT 1.0：在完全可靠信道上的数据传输**

这是最基础的版本，假设底层的信道是**完全可靠**的：

- **信道假设:** 不会发生比特差错，不会丢失分组，分组按序到达，传输延迟恒定（或可忽略）。
- **解决的问题:** 最基本的数据传输。
- **工作原理:** 非常简单。发送方直接发送数据，接收方直接接收数据并向上层交付。不需要任何差错控制、流量控制或序号机制。
- **发送方 (Sender):** 从上层接收数据，调用 `udt_send(packet)` 发送分组。没有状态，只管发送。
- **接收方 (Receiver):** 从下层接收分组，调用 `deliver_data(packet)` 向上层交付数据。没有状态，只管接收。
- **缺陷:** 现实世界中的信道几乎都不可能是完全可靠的。

### **2. RDT 2.0：在比特差错信道上的数据传输**

考虑到信道可能发生比特差错，RDT 2.0 在 RDT 1.0 的基础上增加了错误检测和反馈机制：

- **信道假设:** 可能发生**比特差错**，但**不会丢失分组**，分组按序到达。

- **解决的问题:** 检测并从比特差错中恢复。

- 引入机制:

  - **差错检测 (Error Detection):** 使用**校验和 (Checksum)** 来检测分组中的比特是否发生错误。

  - 接收方反馈 (Feedback):

     接收方需要告知发送方接收到的分组是正确的还是错误的。引入了两种控制报文：

    - **ACK (Acknowledgment):** 肯定确认，表示分组正确。
    - **NAK (Negative Acknowledgment):** 否定确认，表示分组有错。

  - **重传 (Retransmission):** 发送方在收到 NAK 时，重传之前发送的分组。

  - **停-等协议 (Stop-and-Wait):** 发送方发送一个分组后，必须**停止**并**等待**接收方的 ACK 或 NAK，收到反馈后才能发送下一个分组。这确保了在发送新的分组之前，前一个分组已经被正确接收。

- 工作原理:

  - 发送方:
    - 从上层获取数据，生成包含数据和校验和的分组。
    - 发送分组，并进入“等待 ACK 或 NAK”的状态。
    - 收到一个反馈报文：
      - 如果收到的是 NAK：认为之前发送的分组有错，**重传**该分组，继续等待。
      - 如果收到的是 ACK：认为之前发送的分组正确到达，可以从上层获取下一个数据，生成新分组并发送。
  - 接收方:
    - 接收分组。
    - 检查分组的校验和。
      - 如果分组有错：发送 NAK 报文。
      - 如果分组无错：从分组中提取数据向上层交付，发送 ACK 报文。

- **缺陷:** RDT 2.0 无法处理 **ACK 或 NAK 报文本身发生比特差错**的情况。如果发送方收到一个损坏的反馈报文，它无法知道接收方究竟是收到了正确的分组并发送了 ACK，还是收到了错误的分组并发送了 NAK。这时，发送方不知道是应该重传还是发送新分组。

### **3. RDT 2.1：在比特差错信道上处理损坏的反馈报文**

为了解决 ACK/NAK 报文损坏的问题，RDT 2.1 引入了序号和在反馈中包含序号的机制：

- **信道假设:** 可能发生**比特差错**（包括数据分组和反馈报文），但**不会丢失分组**，分组按序到达。

- **解决的问题:** 处理损坏的 ACK/NAK 报文，并防止接收方重复交付数据。

- 引入机制 (在 RDT 2.0 基础上):

  - **序号 (Sequence Number):** 发送方在数据分组中加入序号。由于仍然是停-等协议，只需要用 0 和 1 两个序号就足够了，轮流使用（循环序号）。
  - **在反馈报文中包含序号:** 接收方在发送 ACK 或 NAK 时，包含它所确认/否定确认的分组的序号。

- 工作原理:

  - 发送方:

    - 维护一个变量，记录当前要发送的分组的序号（`seq_num`，初始为 0）。

    - 从上层获取数据，生成包含数据、校验和和 `seq_num` 的分组。

    - 发送分组，进入“等待 ACK 或 NAK `seq_num`”的状态。

    - 收到一个反馈报文：

      - 如果反馈报文**损坏**：发送方不知道接收方收到了什么，采取安全策略：**重传**当前的分组（序号不变），继续等待。

      - 如果反馈报文

        未损坏

        ：检查其中的确认号。

        - 如果确认号与 `seq_num` **匹配**（收到的是当前分组的 ACK）：表示当前分组正确接收，发送方可以发送下一个分组。更新 `seq_num`（0 变 1，1 变 0），从上层获取数据，生成新分组并发送。
        - 如果确认号与 `seq_num` **不匹配**（收到的是前一个分组的 ACK）：这意味着发送方之前发送的分组可能损坏了，接收方因此重新发送了前一个分组的 ACK。或者发送方收到了一个重复的 ACK。无论哪种情况，发送方认为当前分组未被正确接收，采取安全策略：**重传**当前的分组（序号不变），继续等待。

  - 接收方:

    - 维护一个变量，记录当前期望接收的分组的序号（`expected_seq_num`，初始为 0）。

    - 接收分组。

    - 检查分组的校验和。

      - 如果分组**损坏**：丢弃分组，发送一个 NAK 报文，其中包含**期望接收的序号** (`expected_seq_num`)。

      - 如果分组

        未损坏

        ：检查分组中的序号。

        - 如果序号与 `expected_seq_num` **匹配**：这是一个新的、正确接收的分组。接收方向上层**交付**数据。然后，发送一个 ACK 报文，其中包含**接收到的分组的序号**（即 `expected_seq_num`）。更新 `expected_seq_num`（0 变 1，1 变 0）。
        - 如果序号与 `expected_seq_num` **不匹配**：这是一个未损坏但序号错误的分组。这通常是由于发送方重传了之前已经接收并处理过的分组（因为发送方没有收到正确的 ACK）。这个分组是重复的。接收方**丢弃**这个重复的分组（不向上层交付），并**重新发送上一个正确接收到的分组的 ACK**（即发送一个包含当前 `expected_seq_num` *前一个值* 的 ACK）。这就像在说：“我期望的是序号 X，你给了我一个序号 Y，所以这不是我要的，我仍然在等你序号 X 的分组，这是我收到上一个正确分组的 ACK。”

- **缺陷:** RDT 2.1 仍然需要两种类型的反馈报文 (ACK 和 NAK)，增加了协议的复杂性。而且，它仍然**无法处理分组丢失**的情况。

### **4. RDT 2.2：无 NAK 协议**

RDT 2.2 在 RDT 2.1 的基础上进行了简化，移除了 NAK 报文，只使用 ACK。

- **信道假设:** 同 RDT 2.1（可能发生比特差错，不会丢失分组，分组按序到达）。

- **解决的问题:** 消除 NAK 报文，进一步简化协议。

- 引入机制 (在 RDT 2.1 基础上):

  - **重复 ACK (Duplicate ACK):** 接收方不再发送 NAK。如果接收到的分组损坏或序号错误（即重复分组），接收方会发送一个 ACK，其中包含**上一个正确接收并接受的分组的序号**。这种重复发送同一个 ACK 的行为就称为重复 ACK。

- 工作原理:

  - 发送方:

    - 维护 `seq_num`。

    - 从上层获取数据，生成包含数据、校验和和 `seq_num` 的分组。

    - 发送分组，进入“等待 ACK `seq_num`”的状态。

    - 收到一个 ACK 报文：

      - 如果 ACK 报文**损坏**：发送方不知道接收方收到了什么，**重传**当前的分组（序号不变），继续等待。

      - 如果 ACK 报文

        未损坏

        ：检查其中的确认号。

        - 如果确认号与 `seq_num` **匹配**：当前分组正确接收。更新 `seq_num`，发送下一个分组。
        - 如果确认号与 `seq_num` **不匹配**（收到的是前一个分组的 ACK，即重复 ACK）：意味着接收方没有正确接收当前分组（可能损坏或重复）。**重传**当前的分组（序号不变），继续等待。

  - 接收方:

    - 维护 `expected_seq_num`。

    - 接收分组。

    - 检查分组的校验和。

      - 如果分组**损坏**：丢弃分组，发送一个 ACK 报文，其中包含**上一个正确接收到的分组的序号**（即 `expected_seq_num` *之前的值*）。

      - 如果分组

        未损坏

        ：检查分组中的序号。

        - 如果序号与 `expected_seq_num` **匹配**：新的正确分组。向上层**交付**数据。发送 ACK 报文，其中包含**接收到的分组的序号**（即 `expected_seq_num`）。更新 `expected_seq_num`。
        - 如果序号与 `expected_seq_num` **不匹配**：重复分组。丢弃分组，发送一个 ACK 报文，其中包含**上一个正确接收到的分组的序号**（即 `expected_seq_num` *之前的值*）。

- **优点:** 简化了接收方的逻辑，减少了一种报文类型。

- **缺陷:** 仍然**无法处理分组丢失**的情况。

### **5. RDT 3.0：在丢包信道上的数据传输**

RDT 3.0 解决了 RDT 2.x 系列无法处理分组丢失（包括数据分组和 ACK 分组）的问题。

- **信道假设:** 可能发生**比特差错**，可能**丢失分组**（数据分组或反馈报文），分组可能经历**可变延迟**（可能导致超时）。仍然假设分组**按序到达**（在 Stop-and-Wait 模式下丢失和重传不会引入乱序问题，因为每次只处理一个分组）。

- **解决的问题:** 从分组丢失（数据或 ACK）中恢复。

- 引入机制 (在 RDT 2.2 基础上):

  - **定时器 (Timer):** 发送方为每个发送但尚未被确认的分组设置一个定时器。

- 工作原理:

   仍然是停-等协议。

  - 发送方:

    - 维护 `seq_num`。
    - 从上层获取数据，生成包含数据、校验和和 `seq_num` 的分组。
    - **发送分组，并启动一个定时器。** 进入“等待 ACK `seq_num`”的状态。
    - 收到一个 ACK 报文：
      - 如果 ACK 报文**损坏** 或 确认号与 `seq_num` **不匹配** (重复 ACK)：忽略该 ACK（因为它不是针对当前发送的分组的正确确认）。定时器继续运行。
      - 如果 ACK 报文**未损坏** 且 确认号与 `seq_num` **匹配**：表示当前分组正确接收。**停止定时器**。更新 `seq_num`，从上层获取下一个数据，生成新分组并发送，然后**启动新的定时器**。
    - **定时器超时 (Timeout):** 如果在收到正确 ACK 之前，定时器到期，发送方认为之前发送的分组（或其 ACK）可能丢失了。**重传**当前的分组（序号不变），并**重新启动定时器**。

  - 接收方:

    - 维护 `expected_seq_num`。

    - 接收分组。

    - 检查分组的校验和。

      - 如果分组**损坏**：丢弃分组，发送上一个正确接收到的分组的 ACK（包含 `expected_seq_num` 之前的值）。

      - 如果分组

        未损坏

        ：检查分组中的序号。

        - 如果序号与 `expected_seq_num` **匹配**：新的正确分组。向上层**交付**数据。发送当前分组的 ACK（包含 `expected_seq_num`）。更新 `expected_seq_num`。
        - 如果序号与 `expected_seq_num` **不匹配**：重复分组。丢弃分组，发送上一个正确接收到的分组的 ACK（包含 `expected_seq_num` 之前的值）。

    - **注意:** 接收方不需要定时器。它只需要对收到的分组做出反应。对重复分组发送重复 ACK 是处理发送方重传的必要步骤。

- **缺陷:** RDT 3.0 的停-等机制在信道的**带宽-延迟积 (Bandwidth-Delay Product)** 较大时效率非常低下。每次只能发送一个分组然后等待 RTT (Round-Trip Time)，信道大部分时间是空闲的。

**总结:**

RDT 协议的演进是一个逐步应对信道不可靠性的过程：

- **RDT 1.0:** 假设完美信道，只实现基本传输。
- **RDT 2.0:** 引入校验和、ACK/NAK 和停-等，处理**比特差错**。
- **RDT 2.1:** 引入序号和在反馈中包含序号，处理**损坏的 ACK/NAK**，防止重复交付。
- **RDT 2.2:** 移除 NAK，使用**重复 ACK** 来简化协议。
- **RDT 3.0:** 引入**定时器**，处理**分组丢失**（数据或 ACK）和可变延迟导致的超时。

RDT 3.0 已经是一个能够在不可靠信道上实现可靠传输的基本协议。然而，为了提高效率，实际的传输层协议（如 TCP）会采用**流水线机制 (Pipelining)**，允许发送方在未收到确认的情况下发送多个分组，这就需要更复杂的序号、窗口机制以及累计确认、选择重传等技术。但 RDT 协议的这几个版本是理解这些高级机制的基础。

## 流水线协议

正如我们之前提到的，RDT 3.0 虽然解决了丢包问题，但其停-等（Stop-and-Wait）机制效率很低。在发送方发送一个分组后，无论信道有多宽，它都必须等待接收方确认后才能发送下一个。如果信道的**带宽-延迟积 (Bandwidth-Delay Product)** 很大（即信道很宽，同时传输延迟也比较大），这意味着在第一个分组的往返时间（RTT）内，信道上大部分时间是空闲的，大量带宽被浪费了。

**流水线 (Pipelining)** 协议的核心思想就是为了解决这个问题：**允许发送方在收到第一个分组的确认之前，连续发送多个分组。**

想象一下水流通过管道，停等协议就像是每次只放一滴水，等这滴水完全流到另一头并得到确认后，再放下一滴。而流水线协议就像是连续不断地向管道中注水，让多滴水（多个分组）同时在管道中流动。

引入流水线机制后，会带来一些新的挑战，需要协议进行更复杂的设计：

1. **需要更大的序号范围：** 不再是简单的 0 和 1 循环，发送方可能同时有多个分组在空中（in flight），每个分组都需要一个唯一的序号来区分。序号需要在一个更大的范围内循环使用。
2. 发送方和接收方需要缓存 (Buffering)：
   - **发送方：** 需要缓存那些已经发送但尚未收到确认的分组，以便在发生错误时进行重传。
   - **接收方：** 由于分组可能乱序到达（虽然 RDT 3.0 基于的简单信道不考虑乱序，但更高级的 RDT 和实际网络是会发生乱序的，即使不乱序，重传也会导致接收方先收到后面的分组），接收方可能需要缓存那些虽然正确收到但不属于按序到达的下一个分组，直到前面丢失或延迟的分组到达并交付后，才能按顺序向上层交付数据。
3. **差错恢复的处理方式：** 当发生丢包或分组损坏时，发送方如何知道是哪个或哪些分组出了问题？它应该重传所有后续发送的分组（Go-Back-N），还是只重传丢失的那个分组（Selective Repeat）？

基于如何处理这些挑战，特别是差错恢复和接收方缓存策略，出现了两种主要的流水线协议类型：

1. **回退 N 步 (Go-Back-N, GBN)**
2. **选择重传 (Selective Repeat, SR)**

这两种协议都使用**窗口 (Window)** 机制来限制发送方可以发送的未确认分组的数量。发送窗口（Sender Window）的大小为 N，表示发送方最多可以发送 N 个未确认的分组。接收方也有一个接收窗口（Receiver Window）。

我们分别详细讲解这两种协议。

### **1. 回退 N 步 (Go-Back-N, GBN)**

GBN 协议的特点是**接收方的处理比较简单，发送方的处理相对复杂（在错误恢复时）**。

- **发送方:**

  - 维护一个发送窗口，大小为 N。窗口内的序号是允许发送但尚未确认的分组。
  - 维护三个重要的序号：`base` (窗口的起始序号，即最早未被确认的分组的序号)，`nextseqnum` (下一个待发送的分组的序号)。
  - 当上层有数据到来时，如果发送窗口未满 (`nextseqnum < base + N`)，发送方生成分组（包含数据、校验和、序号 `nextseqnum`），发送该分组，并递增 `nextseqnum`。
  - 发送方为**窗口中最早的未确认分组**（序号为 `base` 的分组）启动一个定时器。
  - 接收方通常使用**累计确认 (Cumulative ACK)**：一个序号为 n 的 ACK 报文表示接收方已经正确接收了**所有**序号直到（包括）n 的分组。
  - 当发送方收到一个对序号为 n 的 ACK 报文时，它认为所有序号小于或等于 n 的分组都已经被确认了。发送方将发送窗口的 `base` 移动到 n + 1。如果移动后窗口中有新的未确认分组，并且之前没有定时器在运行（即 `base` 等于 `nextseqnum`，窗口为空，但在发送第一个分组时会启动定时器），则为新的 `base`（也就是最早的未确认分组）启动定时器。
  - **当定时器超时时：** 发送方认为序号为 `base` 的分组（以及所有在其之后发送但在当前窗口内的分组）可能丢失了。发送方不会等待其他分组的确认，它会**立即重传**序号从 `base` 到 `nextseqnum - 1` 的所有已发送但未确认的分组。这就是“回退 N 步”的由来——一旦发生超时，就从发生问题的地方（最早未确认的分组）“回退”到那个位置，并重新发送从那里开始的所有后续分组。之后重新启动定时器。

- **接收方:**

  - 维护一个变量 `expected_seq_num`，表示接收方当前期望接收的按序到达的下一个分组的序号。

  - 接收方是**严格按序接收**的。它只关注序号等于 `expected_seq_num` 的分组。

  - 当接收方收到一个

    未损坏

    的分组：

    - 如果分组的序号**等于** `expected_seq_num`：这是一个按序到达的正确分组。接收方向上层**交付**数据。然后，发送一个针对该分组的 ACK 报文（包含确认号 `expected_seq_num`），并将 `expected_seq_num` 加 1。
    - 如果分组的序号**不等于** `expected_seq_num` (无论是大于还是小于)：这个分组是乱序或重复的。接收方**丢弃**这个分组。为了让发送方知道接收方仍然在等待 `expected_seq_num` 的分组，接收方会**重新发送针对上一个按序接收到的分组的 ACK**（即发送一个包含确认号 `expected_seq_num` - 1 的 ACK）。接收方**不缓存**任何乱序到达的分组。

  - 当接收方收到一个**损坏**的分组：丢弃分组，并发送针对上一个按序接收到的分组的 ACK（包含确认号 `expected_seq_num` - 1）。

- **优点:** 接收方的逻辑非常简单，不需要缓存乱序到达的分组。

- **缺点:** 当信道丢包率较高时，可能会导致大量的重复发送。即使丢失的只是一个分组，发送方可能需要重传其后的 N-1 个分组，而这 N-1 个分组可能接收方已经正确收到了，只是因为前面的分组丢失导致接收方没有移动 `expected_seq_num`。

### **2. 选择重传 (Selective Repeat, SR)**

SR 协议的特点是**发送方的处理相对简单（在错误恢复时），但接收方的处理比较复杂**。SR 旨在通过只重传真正丢失或损坏的分组来提高效率。

- **发送方:**

  - 维护一个发送窗口，大小为 N。窗口内的序号是允许发送但尚未确认的分组。
  - 发送方为**每一个**已发送但未确认的分组都维护一个**单独的定时器**。
  - 发送方发送分组时，为该分组启动定时器。
  - 接收方对每个正确接收的分组发送**独立的 ACK**。
  - 当发送方收到对序号为 n 的 ACK 报文时，它将序号为 n 的分组标记为已确认。如果序号为 n 的分组是当前窗口的 `base` 分组，并且其后的连续分组也已经被确认，发送方会将发送窗口的 `base` 移动到第一个未被确认的分组的序号。
  - **当某个分组的定时器超时时：** 发送方认为**只有这个**分组可能丢失了。发送方**只重传**这个特定的分组。

- **接收方:**

  - 维护一个接收窗口，大小通常也为 N（为了避免序号空间的歧义，发送窗口和接收窗口的大小 N 必须满足 2N≤序号空间大小）。接收窗口表示接收方愿意接受的序号范围。

  - 维护一个**接收缓存**。接收方可以接收并缓存**窗口内**的**任何**正确到达的分组，即使它不是按序到达的下一个分组。

  - 维护 `expected_seq_num`，表示接收方期望交付给上层的按序到达的下一个分组的序号（即接收窗口的下边界）。

  - 当接收方收到一个

    未损坏

    的分组：

    - 如果分组的序号**在接收窗口内** (`expected_seq_num` ≤ 序号 ≤ `expected_seq_num + N - 1`): 这是一个有效分组。将该分组放入接收缓存中。发送一个针对该分组的**独立 ACK**。
    - 如果分组的序号**小于** `expected_seq_num`：这是一个重复分组（之前已经接收并交付了）。发送针对该分组的独立 ACK（以防发送方没有收到之前的 ACK）。
    - 如果分组的序号**大于** `expected_seq_num + N - 1`：这是窗口外的高序号分组。丢弃该分组。

  - 当接收方收到一个**损坏**的分组：丢弃该分组。

  - **向上层交付数据：** 接收方检查缓存，如果序号为 `expected_seq_num` 的分组以及其后的一段连续分组都已正确收到并保存在缓存中，接收方就将这些连续的分组**按序**向上层交付，并更新 `expected_seq_num` 为下一个未交付的分组的序号，同时将接收窗口向前移动。

- **优点:** 只重传丢失或损坏的分组，减少了不必要的重传，在丢包率高的信道上效率更高。

- **缺点:** 接收方的逻辑更复杂，需要维护接收缓存，并为每个正确接收的分组发送独立的 ACK，还需要判断何时可以将缓存中的连续分组交付给上层。对序号空间的大小也有更严格的要求。

**总结 流水线协议：**

流水线协议通过允许同时发送多个分组来解决停-等协议的效率低下问题。GBN 和 SR 是两种主要的实现方式，它们在差错恢复策略、发送方和接收方的复杂性以及对信道特性的适应性上有所不同：

- **GBN:** 接收方简单，丢弃乱序分组，使用累计确认，超时后重传窗口内的所有分组。适用于信道丢包率较低的情况。
- **SR:** 接收方复杂，缓存乱序分组，使用独立确认，超时后只重传单个分组。适用于信道丢包率较高的情况。

实际的协议，如 TCP，通常借鉴了这两种协议的思想，形成了一种混合方式。TCP 使用累计确认（像 GBN），但通过快速重传（Fast Retransmit，基于重复 ACK 的机制）和选择确认（Selective Acknowledgment, SACK）等机制，又具备了一些 SR 的特性，尽量避免不必要的重传。

理解 RDT 协议从 1.0 到 3.0 再到流水线（GBN 和 SR）的发展过程，有助于我们理解 TCP 等复杂传输层协议的设计原理和面临的挑战。