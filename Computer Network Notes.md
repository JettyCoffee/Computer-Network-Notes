# Computer Network Notes

# Chapter 1 计网与因特网

# Chapter 2 应用层

我们把计算机网络想象成一个复杂的物流系统。你要寄一封信（数据）给远方的朋友。

- 你写的信的内容、信的格式（比如是情书还是商业信函）、你希望对方收到信后做什么（比如阅读、回复），这些就是**应用层**关心的。
- 你把信交给邮局，邮局怎么把信送到对方城市的邮局，怎么保证信件中途不丢失、不出错，那是下面几层（传输层、网络层等）的工作。

**应用层是计算机网络体系结构中的最顶层，它直接为用户的应用程序提供服务。** 简单来说，我们日常使用的几乎所有联网的软件，比如浏览器、邮件客户端、FTP工具、微信、QQ、在线游戏等等，它们的核心网络功能都是在应用层实现的。

------

## **应用层的核心作用与功能：**

1. **定义应用程序间的通信规则 (Protocols):**
   - 这是应用层的核心！它定义了不同主机上运行的应用程序之间如何交换信息。
   - 这些规则包括：
     - **报文类型 (Message Types):** 比如是请求报文还是响应报文。HTTP中就有GET请求、POST请求，以及200 OK响应、404 Not Found响应等。
     - **报文语法 (Message Syntax):** 报文中各个字段的含义和结构。比如HTTP头部有哪些字段，每个字段代表什么。
     - **报文语义 (Message Semantics):** 对报文中各个字段的解释，以及接收方应该如何响应。
     - **交互顺序 (Rules for when and how processes send and respond to messages):** 比如客户端必须先发送请求，服务器才能发送响应。
2. **为用户提供网络服务：**
   - 应用层协议使得应用程序能够透明地使用网络资源，而无需关心底层网络的复杂细节。用户只需要关心“我要访问哪个网页”、“我要发送什么邮件”。
3. **数据表示与转换 (Presentation Layer Functions - Often Integrated):**
   - 在OSI七层模型中，表示层负责数据的编码、解码、加密、解密、压缩、解压缩等。在TCP/IP模型中，这些功能通常被整合到应用层协议中。
   - 例如，HTTP协议可以传输HTML、图片、视频等不同格式的数据，它会通过`Content-Type`头部字段指明数据的类型。浏览器收到后就知道如何解析和显示。
4. **会话管理 (Session Layer Functions - Often Integrated):**
   - 在OSI模型中，会话层负责建立、管理和终止应用程序之间的会话。在TCP/IP模型中，这些功能也常常由应用层协议自己实现，或者依赖于传输层（如TCP）提供的连接管理。
   - 例如，FTP协议在控制连接之外还会建立数据连接来传输文件，这就是一种会话管理。

------

## **两种主要的应用层体系结构 (Architectural Models):**

### **客户机/服务器模型 (Client/Server Model):**

- 这是最常见的模型。
- **服务器 (Server):** 一个总是开启的主机，等待并响应来自多个客户机的请求。通常拥有固定的、众所周知的IP地址和端口号。例如，Web服务器、邮件服务器。
- **客户机 (Client):** 一个主动发起通信的主机，向服务器发送请求，并接收服务器的响应。通常是用户的PC、手机等。客户机在需要服务时才与服务器通信，IP地址可能是动态的。
- 特点：
  - 服务器是被动的，等待请求。
  - 客户机是主动的，发起请求。
  - 数据流向通常是双向的，但由客户机启动。
  - 易于管理和维护，因为服务集中在服务器上。
  - 服务器可能成为性能瓶颈或单点故障。
- **例子：** Web浏览 (HTTP), 文件传输 (FTP), 电子邮件 (SMTP, POP3, IMAP)。

1. #### **对等模型 (Peer-to-Peer, P2P Model):**

   - 在这种模型中，网络中的每个主机（称为对等方或Peer）既可以作为客户机请求服务，也可以作为服务器提供服务。
   - 对等方之间直接通信，无需经过专门的服务器（或者只需要一个轻量级的服务器用于发现其他对等方）。
   - 特点：
     - 没有永远在线的服务器。
     - 任意端系统之间可以直接通信。
     - 每个对等方既是资源的提供者也是消费者。
     - 可扩展性好，不容易出现单点故障。
     - 管理相对复杂。
   - **例子：** BitTorrent (文件共享), Skype (早期版本), 一些区块链应用。

------

## **应用层如何与传输层交互：**

应用层的应用程序需要通过传输层提供的服务来发送和接收报文。

### **进程寻址 (Port Numbers):**

- 一台主机上可能同时运行着多个网络应用程序（比如浏览器、邮件客户端、QQ）。当传输层从网络层接收到数据段 (Segment) 后，它需要知道应该将这个数据段交给哪个应用程序。
- 这就是**端口号 (Port Number)** 的作用。每个需要网络通信的应用程序都会被分配一个或多个端口号。
- IP地址标识了主机，而端口号标识了主机上的特定应用程序进程。
- **IP地址 + 端口号 = 套接字 (Socket)**。一个网络通信就是两个套接字之间的通信。
- **知名端口 (Well-known Ports):** 0-1023，分配给常用的服务，例如HTTP (80), FTP (21), HTTPS (443), SMTP (25)。
- **注册端口 (Registered Ports):** 1024-49151，供应用程序开发商注册。
- **动态/私有端口 (Dynamic/Private Ports):** 49152-65535，客户端通常使用这些端口。

### **选择传输层协议 (TCP or UDP):**

- 应用层协议的设计者会根据应用的需求选择使用TCP还是UDP。
- TCP (Transmission Control Protocol):
  - **面向连接的 (Connection-oriented):** 在数据传输前建立连接，传输结束后释放连接。
  - **可靠的数据传输 (Reliable data transfer):** 保证数据不丢失、不重复、按序到达。通过序列号、确认、重传机制实现。
  - **流量控制 (Flow control):** 防止发送方发送过多数据，压垮接收方。
  - **拥塞控制 (Congestion control):** 当网络拥堵时，减慢发送速率。
  - **适用于：** 对数据完整性和顺序要求高的应用，如HTTP, FTP, SMTP, SSH。
- UDP (User Datagram Protocol):
  - **无连接的 (Connectionless):** 发送数据前不需要建立连接。
  - **不可靠的数据传输 (Unreliable data transfer):** "尽力而为"的服务，不保证数据到达、不保证顺序、不保证不重复。
  - **开销小，速度快：** 没有TCP那些复杂的控制机制。
  - **适用于：** 对实时性要求高、能容忍少量数据丢失的应用，如DNS, DHCP, 流媒体（如视频会议、在线直播，但这些应用通常会在应用层自己实现一定的可靠性机制）。

------

## **常见的应用层协议详解：**

让我们深入了解几个最重要的应用层协议：

### **HTTP (HyperText Transfer Protocol - 超文本传输协议):**

- **用途：** Web的核心。用于从Web服务器传输超文本到本地浏览器。
- **模型：** 客户机/服务器模型。浏览器是客户机，Web服务器是服务器。
- 特点：
  - **无状态 (Stateless):** 服务器不保存关于客户机先前请求的任何信息。每个请求都是独立的。（为了解决这个问题，引入了Cookies等机制）。
  - **灵活：** 可以传输任何类型的数据（文本、图像、音频、视频等），通过MIME类型来区分。
- 工作过程：
  1. 浏览器（客户端）与Web服务器在TCP端口80（HTTPS是443）建立TCP连接。
  2. 浏览器发送HTTP请求报文（例如 `GET /index.html HTTP/1.1`）。
  3. 服务器接收请求，处理后发送HTTP响应报文（例如 `HTTP/1.1 200 OK` 加上网页内容）。
  4. 浏览器接收响应，解析并显示内容。
  5. TCP连接关闭（HTTP/1.0中每个请求/响应对都关闭连接；HTTP/1.1引入了持久连接，允许在同一连接上传输多个请求/响应）。
- 常用方法 (Methods):
  - `GET`: 请求获取指定资源。
  - `POST`: 向服务器提交数据（例如表单数据）。
  - `HEAD`: 类似于GET，但服务器只返回头部信息，不返回实际内容。
  - `PUT`: 用请求中的数据替换服务器上的指定文档。
  - `DELETE`: 删除服务器上的指定资源。
- **HTTPS (HTTP Secure):** HTTP的安全版本，通过SSL/TLS对HTTP通信进行加密，确保数据传输的机密性和完整性。使用TCP端口443。

### **DNS (Domain Name System - 域名系统):**

- **用途：** 将人类易于记忆的域名（如 `www.google.com`）解析为机器能够理解的IP地址（如 `172.217.160.142`）。也可以进行反向解析（IP到域名）。
- **模型：** 分布式的、层次化的客户机/服务器模型。
- 工作过程（简化版）：
  1. 用户在浏览器输入 `www.example.com`。
  2. 浏览器/操作系统（DNS客户端）向其配置的**本地DNS服务器**发送DNS查询请求。
  3. 如果本地DNS服务器有缓存记录，直接返回IP地址。
  4. 否则，本地DNS服务器会向**根DNS服务器**查询。
  5. 根服务器告诉本地DNS服务器去查询负责 `.com` 域的**顶级域 (TLD) DNS服务器**。
  6. TLD DNS服务器告诉本地DNS服务器去查询负责 `example.com` 域的**权威DNS服务器**。
  7. 权威DNS服务器将 `www.example.com` 对应的IP地址返回给本地DNS服务器。
  8. 本地DNS服务器将IP地址返回给用户的计算机，并缓存该记录。
- **传输协议：** 主要使用UDP端口53（查询请求小，追求速度）。当DNS响应报文超过UDP的512字节限制时，或者进行区域传送（Zone Transfer，主辅DNS服务器间同步数据）时，会使用TCP端口53。

### **FTP (File Transfer Protocol - 文件传输协议):**

- **用途：** 在客户机和服务器之间进行文件传输（上传和下载）。
- **模型：** 客户机/服务器模型。
- 特殊之处：使用两个并行的TCP连接！
  - **控制连接 (Control Connection):** TCP端口21。用于传输控制信息，如用户身份验证、命令（如`LIST`, `RETR`, `STOR`）、响应。在整个会话期间保持打开。
  - **数据连接 (Data Connection):** TCP端口20（服务器主动模式）或一个临时端口（服务器被动模式）。用于实际传输文件内容。每次文件传输都会建立一个新的数据连接，传输完毕后关闭。
- 模式：
  - **主动模式 (Active Mode):** 客户端告诉服务器自己的IP和端口，服务器从自己的20号端口主动连接客户端的指定端口来建立数据连接。
  - **被动模式 (Passive Mode - PASV):** 客户端发送PASV命令给服务器，服务器在某个临时端口等待连接，并将这个IP和端口号告诉客户端，客户端主动连接服务器的这个端口来建立数据连接。（这种模式能更好地穿透客户端的防火墙）。

### **电子邮件协议 (Email Protocols):**

- 电子邮件系统主要涉及三个协议：SMTP, POP3, IMAP。
- SMTP (Simple Mail Transfer Protocol - 简单邮件传输协议):
  - **用途：** 用于从邮件客户端（或邮件服务器）**发送**邮件到邮件服务器，以及在邮件服务器之间**中转**邮件。
  - **模型：** 客户机/服务器模型。
  - **传输协议：** TCP端口25。
  - **特点：** "推"协议，将邮件从发送方推送到接收方邮件服务器。
- POP3 (Post Office Protocol version 3 - 邮局协议版本3):
  - **用途：** 用于邮件客户端从邮件服务器上**拉取**（下载）邮件到本地。
  - **模型：** 客户机/服务器模型。
  - **传输协议：** TCP端口110。
  - **特点：** "拉"协议。通常情况下，邮件下载到本地后，服务器上的副本会被删除（也可以配置为保留）。用户只能在一个设备上管理邮件。
- IMAP (Internet Message Access Protocol - 互联网消息访问协议):
  - **用途：** 也用于邮件客户端从邮件服务器上**访问**邮件，但功能更强大。
  - **模型：** 客户机/服务器模型。
  - **传输协议：** TCP端口143。
  - **特点：** "拉"协议。邮件保留在服务器上，用户可以在多个设备上管理邮件，状态（如已读、未读、删除）会在所有设备间同步。支持在服务器上创建文件夹、搜索邮件等。

1. **DHCP (Dynamic Host Configuration Protocol - 动态主机配置协议):**
   - **用途：** 自动为网络中的主机分配IP地址、子网掩码、默认网关、DNS服务器等网络配置信息。
   - **模型：** 客户机/服务器模型。新接入网络的主机是客户机，网络中需要有DHCP服务器。
   - **传输协议：** UDP。客户端使用端口68，服务器使用端口67。
   - 工作过程 (DORA):
     1. **Discover:** 客户端广播DHCP发现报文。
     2. **Offer:** DHCP服务器收到后，单播（或广播）DHCP提供报文，包含一个可用的IP地址等信息。
     3. **Request:** 客户端选择一个Offer，广播DHCP请求报文，确认希望使用该IP地址。
     4. **Acknowledge:** 被选择的DHCP服务器发送DHCP确认报文，正式将IP地址分配给客户端，并包含租期。

------

## **应用层协议的设计原则：**

- **明确需求：** 这个应用是做什么的？需要什么样的通信特性？（可靠性、实时性、带宽要求等）
- **报文格式：** 定义清晰的请求和响应报文结构。
- **状态管理：** 应用是无状态的还是有状态的？
- **安全性：** 是否需要加密、认证？
- **可扩展性：** 协议是否容易扩展以支持新功能？

------

**总结一下，对于应用层，你需要理解：**

1. **它是最靠近用户的一层**，直接为应用程序服务。
2. **核心是应用层协议**，定义了应用程序之间如何通信。
3. **有两种主要的体系结构：** C/S 和 P2P。
4. **依赖传输层提供的服务** (TCP或UDP)，并通过**端口号**标识不同的应用进程。
5. **熟悉常见的应用层协议** (HTTP, DNS, FTP, SMTP, POP3, IMAP, DHCP) 的用途、工作原理和特点。

# Chapter 3 运输层

## RDT协议发展

RDT 的目标是在一个**不可靠的信道 (unreliable channel)** 上实现**可靠的数据传输**。不可靠的信道可能具备以下一个或多个特性：

1. **比特差错 (Bit Errors):** 传输过程中，分组中的比特可能会发生翻转。
2. **分组丢失 (Packet Loss):** 整个分组可能在传输过程中丢失，永远不会到达目的地。
3. **分组乱序 (Packet Reordering):** 分组可能不按发送顺序到达目的地（虽然 RDT 3.0 的基本停等协议不涉及乱序，但更高级的 RDT 协议会考虑这一点）。
4. **分组延迟 (Packet Delay):** 分组可能经历不同的传输延迟。

RDT 的演进就是针对这些信道不可靠性的逐步增强协议的能力。我们从最简单、最理想的情况开始。

### **1. RDT 1.0：在完全可靠信道上的数据传输**

这是最基础的版本，假设底层的信道是**完全可靠**的：

- **信道假设:** 不会发生比特差错，不会丢失分组，分组按序到达，传输延迟恒定（或可忽略）。
- **解决的问题:** 最基本的数据传输。
- **工作原理:** 非常简单。发送方直接发送数据，接收方直接接收数据并向上层交付。不需要任何差错控制、流量控制或序号机制。
- **发送方 (Sender):** 从上层接收数据，调用 `udt_send(packet)` 发送分组。没有状态，只管发送。
- **接收方 (Receiver):** 从下层接收分组，调用 `deliver_data(packet)` 向上层交付数据。没有状态，只管接收。
- **缺陷:** 现实世界中的信道几乎都不可能是完全可靠的。

### **2. RDT 2.0：在比特差错信道上的数据传输**

考虑到信道可能发生比特差错，RDT 2.0 在 RDT 1.0 的基础上增加了错误检测和反馈机制：

- **信道假设:** 可能发生**比特差错**，但**不会丢失分组**，分组按序到达。

- **解决的问题:** 检测并从比特差错中恢复。

- 引入机制:

  - **差错检测 (Error Detection):** 使用**校验和 (Checksum)** 来检测分组中的比特是否发生错误。

  - 接收方反馈 (Feedback):

     接收方需要告知发送方接收到的分组是正确的还是错误的。引入了两种控制报文：

    - **ACK (Acknowledgment):** 肯定确认，表示分组正确。
    - **NAK (Negative Acknowledgment):** 否定确认，表示分组有错。

  - **重传 (Retransmission):** 发送方在收到 NAK 时，重传之前发送的分组。

  - **停-等协议 (Stop-and-Wait):** 发送方发送一个分组后，必须**停止**并**等待**接收方的 ACK 或 NAK，收到反馈后才能发送下一个分组。这确保了在发送新的分组之前，前一个分组已经被正确接收。

- 工作原理:

  - 发送方:
    - 从上层获取数据，生成包含数据和校验和的分组。
    - 发送分组，并进入“等待 ACK 或 NAK”的状态。
    - 收到一个反馈报文：
      - 如果收到的是 NAK：认为之前发送的分组有错，**重传**该分组，继续等待。
      - 如果收到的是 ACK：认为之前发送的分组正确到达，可以从上层获取下一个数据，生成新分组并发送。
  - 接收方:
    - 接收分组。
    - 检查分组的校验和。
      - 如果分组有错：发送 NAK 报文。
      - 如果分组无错：从分组中提取数据向上层交付，发送 ACK 报文。

- **缺陷:** RDT 2.0 无法处理 **ACK 或 NAK 报文本身发生比特差错**的情况。如果发送方收到一个损坏的反馈报文，它无法知道接收方究竟是收到了正确的分组并发送了 ACK，还是收到了错误的分组并发送了 NAK。这时，发送方不知道是应该重传还是发送新分组。

### **3. RDT 2.1：在比特差错信道上处理损坏的反馈报文**

为了解决 ACK/NAK 报文损坏的问题，RDT 2.1 引入了序号和在反馈中包含序号的机制：

- **信道假设:** 可能发生**比特差错**（包括数据分组和反馈报文），但**不会丢失分组**，分组按序到达。

- **解决的问题:** 处理损坏的 ACK/NAK 报文，并防止接收方重复交付数据。

- 引入机制 (在 RDT 2.0 基础上):

  - **序号 (Sequence Number):** 发送方在数据分组中加入序号。由于仍然是停-等协议，只需要用 0 和 1 两个序号就足够了，轮流使用（循环序号）。
  - **在反馈报文中包含序号:** 接收方在发送 ACK 或 NAK 时，包含它所确认/否定确认的分组的序号。

- 工作原理:

  - 发送方:

    - 维护一个变量，记录当前要发送的分组的序号（`seq_num`，初始为 0）。

    - 从上层获取数据，生成包含数据、校验和和 `seq_num` 的分组。

    - 发送分组，进入“等待 ACK 或 NAK `seq_num`”的状态。

    - 收到一个反馈报文：

      - 如果反馈报文**损坏**：发送方不知道接收方收到了什么，采取安全策略：**重传**当前的分组（序号不变），继续等待。

      - 如果反馈报文

        未损坏

        ：检查其中的确认号。

        - 如果确认号与 `seq_num` **匹配**（收到的是当前分组的 ACK）：表示当前分组正确接收，发送方可以发送下一个分组。更新 `seq_num`（0 变 1，1 变 0），从上层获取数据，生成新分组并发送。
        - 如果确认号与 `seq_num` **不匹配**（收到的是前一个分组的 ACK）：这意味着发送方之前发送的分组可能损坏了，接收方因此重新发送了前一个分组的 ACK。或者发送方收到了一个重复的 ACK。无论哪种情况，发送方认为当前分组未被正确接收，采取安全策略：**重传**当前的分组（序号不变），继续等待。

  - 接收方:

    - 维护一个变量，记录当前期望接收的分组的序号（`expected_seq_num`，初始为 0）。

    - 接收分组。

    - 检查分组的校验和。

      - 如果分组**损坏**：丢弃分组，发送一个 NAK 报文，其中包含**期望接收的序号** (`expected_seq_num`)。

      - 如果分组

        未损坏

        ：检查分组中的序号。

        - 如果序号与 `expected_seq_num` **匹配**：这是一个新的、正确接收的分组。接收方向上层**交付**数据。然后，发送一个 ACK 报文，其中包含**接收到的分组的序号**（即 `expected_seq_num`）。更新 `expected_seq_num`（0 变 1，1 变 0）。
        - 如果序号与 `expected_seq_num` **不匹配**：这是一个未损坏但序号错误的分组。这通常是由于发送方重传了之前已经接收并处理过的分组（因为发送方没有收到正确的 ACK）。这个分组是重复的。接收方**丢弃**这个重复的分组（不向上层交付），并**重新发送上一个正确接收到的分组的 ACK**（即发送一个包含当前 `expected_seq_num` *前一个值* 的 ACK）。这就像在说：“我期望的是序号 X，你给了我一个序号 Y，所以这不是我要的，我仍然在等你序号 X 的分组，这是我收到上一个正确分组的 ACK。”

- **缺陷:** RDT 2.1 仍然需要两种类型的反馈报文 (ACK 和 NAK)，增加了协议的复杂性。而且，它仍然**无法处理分组丢失**的情况。

### **4. RDT 2.2：无 NAK 协议**

RDT 2.2 在 RDT 2.1 的基础上进行了简化，移除了 NAK 报文，只使用 ACK。

- **信道假设:** 同 RDT 2.1（可能发生比特差错，不会丢失分组，分组按序到达）。

- **解决的问题:** 消除 NAK 报文，进一步简化协议。

- 引入机制 (在 RDT 2.1 基础上):

  - **重复 ACK (Duplicate ACK):** 接收方不再发送 NAK。如果接收到的分组损坏或序号错误（即重复分组），接收方会发送一个 ACK，其中包含**上一个正确接收并接受的分组的序号**。这种重复发送同一个 ACK 的行为就称为重复 ACK。

- 工作原理:

  - 发送方:

    - 维护 `seq_num`。

    - 从上层获取数据，生成包含数据、校验和和 `seq_num` 的分组。

    - 发送分组，进入“等待 ACK `seq_num`”的状态。

    - 收到一个 ACK 报文：

      - 如果 ACK 报文**损坏**：发送方不知道接收方收到了什么，**重传**当前的分组（序号不变），继续等待。

      - 如果 ACK 报文

        未损坏

        ：检查其中的确认号。

        - 如果确认号与 `seq_num` **匹配**：当前分组正确接收。更新 `seq_num`，发送下一个分组。
        - 如果确认号与 `seq_num` **不匹配**（收到的是前一个分组的 ACK，即重复 ACK）：意味着接收方没有正确接收当前分组（可能损坏或重复）。**重传**当前的分组（序号不变），继续等待。

  - 接收方:

    - 维护 `expected_seq_num`。

    - 接收分组。

    - 检查分组的校验和。

      - 如果分组**损坏**：丢弃分组，发送一个 ACK 报文，其中包含**上一个正确接收到的分组的序号**（即 `expected_seq_num` *之前的值*）。

      - 如果分组

        未损坏

        ：检查分组中的序号。

        - 如果序号与 `expected_seq_num` **匹配**：新的正确分组。向上层**交付**数据。发送 ACK 报文，其中包含**接收到的分组的序号**（即 `expected_seq_num`）。更新 `expected_seq_num`。
        - 如果序号与 `expected_seq_num` **不匹配**：重复分组。丢弃分组，发送一个 ACK 报文，其中包含**上一个正确接收到的分组的序号**（即 `expected_seq_num` *之前的值*）。

- **优点:** 简化了接收方的逻辑，减少了一种报文类型。

- **缺陷:** 仍然**无法处理分组丢失**的情况。

### **5. RDT 3.0：在丢包信道上的数据传输**

RDT 3.0 解决了 RDT 2.x 系列无法处理分组丢失（包括数据分组和 ACK 分组）的问题。

- **信道假设:** 可能发生**比特差错**，可能**丢失分组**（数据分组或反馈报文），分组可能经历**可变延迟**（可能导致超时）。仍然假设分组**按序到达**（在 Stop-and-Wait 模式下丢失和重传不会引入乱序问题，因为每次只处理一个分组）。

- **解决的问题:** 从分组丢失（数据或 ACK）中恢复。

- 引入机制 (在 RDT 2.2 基础上):

  - **定时器 (Timer):** 发送方为每个发送但尚未被确认的分组设置一个定时器。

- 工作原理:

   仍然是停-等协议。

  - 发送方:

    - 维护 `seq_num`。
    - 从上层获取数据，生成包含数据、校验和和 `seq_num` 的分组。
    - **发送分组，并启动一个定时器。** 进入“等待 ACK `seq_num`”的状态。
    - 收到一个 ACK 报文：
      - 如果 ACK 报文**损坏** 或 确认号与 `seq_num` **不匹配** (重复 ACK)：忽略该 ACK（因为它不是针对当前发送的分组的正确确认）。定时器继续运行。
      - 如果 ACK 报文**未损坏** 且 确认号与 `seq_num` **匹配**：表示当前分组正确接收。**停止定时器**。更新 `seq_num`，从上层获取下一个数据，生成新分组并发送，然后**启动新的定时器**。
    - **定时器超时 (Timeout):** 如果在收到正确 ACK 之前，定时器到期，发送方认为之前发送的分组（或其 ACK）可能丢失了。**重传**当前的分组（序号不变），并**重新启动定时器**。

  - 接收方:

    - 维护 `expected_seq_num`。

    - 接收分组。

    - 检查分组的校验和。

      - 如果分组**损坏**：丢弃分组，发送上一个正确接收到的分组的 ACK（包含 `expected_seq_num` 之前的值）。

      - 如果分组

        未损坏

        ：检查分组中的序号。

        - 如果序号与 `expected_seq_num` **匹配**：新的正确分组。向上层**交付**数据。发送当前分组的 ACK（包含 `expected_seq_num`）。更新 `expected_seq_num`。
        - 如果序号与 `expected_seq_num` **不匹配**：重复分组。丢弃分组，发送上一个正确接收到的分组的 ACK（包含 `expected_seq_num` 之前的值）。

    - **注意:** 接收方不需要定时器。它只需要对收到的分组做出反应。对重复分组发送重复 ACK 是处理发送方重传的必要步骤。

- **缺陷:** RDT 3.0 的停-等机制在信道的**带宽-延迟积 (Bandwidth-Delay Product)** 较大时效率非常低下。每次只能发送一个分组然后等待 RTT (Round-Trip Time)，信道大部分时间是空闲的。

**总结:**

RDT 协议的演进是一个逐步应对信道不可靠性的过程：

- **RDT 1.0:** 假设完美信道，只实现基本传输。
- **RDT 2.0:** 引入校验和、ACK/NAK 和停-等，处理**比特差错**。
- **RDT 2.1:** 引入序号和在反馈中包含序号，处理**损坏的 ACK/NAK**，防止重复交付。
- **RDT 2.2:** 移除 NAK，使用**重复 ACK** 来简化协议。
- **RDT 3.0:** 引入**定时器**，处理**分组丢失**（数据或 ACK）和可变延迟导致的超时。

RDT 3.0 已经是一个能够在不可靠信道上实现可靠传输的基本协议。然而，为了提高效率，实际的传输层协议（如 TCP）会采用**流水线机制 (Pipelining)**，允许发送方在未收到确认的情况下发送多个分组，这就需要更复杂的序号、窗口机制以及累计确认、选择重传等技术。但 RDT 协议的这几个版本是理解这些高级机制的基础。

## 流水线协议

正如我们之前提到的，RDT 3.0 虽然解决了丢包问题，但其停-等（Stop-and-Wait）机制效率很低。在发送方发送一个分组后，无论信道有多宽，它都必须等待接收方确认后才能发送下一个。如果信道的**带宽-延迟积 (Bandwidth-Delay Product)** 很大（即信道很宽，同时传输延迟也比较大），这意味着在第一个分组的往返时间（RTT）内，信道上大部分时间是空闲的，大量带宽被浪费了。

**流水线 (Pipelining)** 协议的核心思想就是为了解决这个问题：**允许发送方在收到第一个分组的确认之前，连续发送多个分组。**

想象一下水流通过管道，停等协议就像是每次只放一滴水，等这滴水完全流到另一头并得到确认后，再放下一滴。而流水线协议就像是连续不断地向管道中注水，让多滴水（多个分组）同时在管道中流动。

引入流水线机制后，会带来一些新的挑战，需要协议进行更复杂的设计：

1. **需要更大的序号范围：** 不再是简单的 0 和 1 循环，发送方可能同时有多个分组在空中（in flight），每个分组都需要一个唯一的序号来区分。序号需要在一个更大的范围内循环使用。
2. 发送方和接收方需要缓存 (Buffering)：
   - **发送方：** 需要缓存那些已经发送但尚未收到确认的分组，以便在发生错误时进行重传。
   - **接收方：** 由于分组可能乱序到达（虽然 RDT 3.0 基于的简单信道不考虑乱序，但更高级的 RDT 和实际网络是会发生乱序的，即使不乱序，重传也会导致接收方先收到后面的分组），接收方可能需要缓存那些虽然正确收到但不属于按序到达的下一个分组，直到前面丢失或延迟的分组到达并交付后，才能按顺序向上层交付数据。
3. **差错恢复的处理方式：** 当发生丢包或分组损坏时，发送方如何知道是哪个或哪些分组出了问题？它应该重传所有后续发送的分组（Go-Back-N），还是只重传丢失的那个分组（Selective Repeat）？

基于如何处理这些挑战，特别是差错恢复和接收方缓存策略，出现了两种主要的流水线协议类型：

1. **回退 N 步 (Go-Back-N, GBN)**
2. **选择重传 (Selective Repeat, SR)**

这两种协议都使用**窗口 (Window)** 机制来限制发送方可以发送的未确认分组的数量。发送窗口（Sender Window）的大小为 N，表示发送方最多可以发送 N 个未确认的分组。接收方也有一个接收窗口（Receiver Window）。

我们分别详细讲解这两种协议。

### **1. 回退 N 步 (Go-Back-N, GBN)**

GBN 协议的特点是**接收方的处理比较简单，发送方的处理相对复杂（在错误恢复时）**。

- **发送方:**

  - 维护一个发送窗口，大小为 N。窗口内的序号是允许发送但尚未确认的分组。
  - 维护三个重要的序号：`base` (窗口的起始序号，即最早未被确认的分组的序号)，`nextseqnum` (下一个待发送的分组的序号)。
  - 当上层有数据到来时，如果发送窗口未满 (`nextseqnum < base + N`)，发送方生成分组（包含数据、校验和、序号 `nextseqnum`），发送该分组，并递增 `nextseqnum`。
  - 发送方为**窗口中最早的未确认分组**（序号为 `base` 的分组）启动一个定时器。
  - 接收方通常使用**累计确认 (Cumulative ACK)**：一个序号为 n 的 ACK 报文表示接收方已经正确接收了**所有**序号直到（包括）n 的分组。
  - 当发送方收到一个对序号为 n 的 ACK 报文时，它认为所有序号小于或等于 n 的分组都已经被确认了。发送方将发送窗口的 `base` 移动到 n + 1。如果移动后窗口中有新的未确认分组，并且之前没有定时器在运行（即 `base` 等于 `nextseqnum`，窗口为空，但在发送第一个分组时会启动定时器），则为新的 `base`（也就是最早的未确认分组）启动定时器。
  - **当定时器超时时：** 发送方认为序号为 `base` 的分组（以及所有在其之后发送但在当前窗口内的分组）可能丢失了。发送方不会等待其他分组的确认，它会**立即重传**序号从 `base` 到 `nextseqnum - 1` 的所有已发送但未确认的分组。这就是“回退 N 步”的由来——一旦发生超时，就从发生问题的地方（最早未确认的分组）“回退”到那个位置，并重新发送从那里开始的所有后续分组。之后重新启动定时器。

- **接收方:**

  - 维护一个变量 `expected_seq_num`，表示接收方当前期望接收的按序到达的下一个分组的序号。

  - 接收方是**严格按序接收**的。它只关注序号等于 `expected_seq_num` 的分组。

  - 当接收方收到一个

    未损坏

    的分组：

    - 如果分组的序号**等于** `expected_seq_num`：这是一个按序到达的正确分组。接收方向上层**交付**数据。然后，发送一个针对该分组的 ACK 报文（包含确认号 `expected_seq_num`），并将 `expected_seq_num` 加 1。
    - 如果分组的序号**不等于** `expected_seq_num` (无论是大于还是小于)：这个分组是乱序或重复的。接收方**丢弃**这个分组。为了让发送方知道接收方仍然在等待 `expected_seq_num` 的分组，接收方会**重新发送针对上一个按序接收到的分组的 ACK**（即发送一个包含确认号 `expected_seq_num` - 1 的 ACK）。接收方**不缓存**任何乱序到达的分组。

  - 当接收方收到一个**损坏**的分组：丢弃分组，并发送针对上一个按序接收到的分组的 ACK（包含确认号 `expected_seq_num` - 1）。

- **优点:** 接收方的逻辑非常简单，不需要缓存乱序到达的分组。

- **缺点:** 当信道丢包率较高时，可能会导致大量的重复发送。即使丢失的只是一个分组，发送方可能需要重传其后的 N-1 个分组，而这 N-1 个分组可能接收方已经正确收到了，只是因为前面的分组丢失导致接收方没有移动 `expected_seq_num`。

### **2. 选择重传 (Selective Repeat, SR)**

SR 协议的特点是**发送方的处理相对简单（在错误恢复时），但接收方的处理比较复杂**。SR 旨在通过只重传真正丢失或损坏的分组来提高效率。

- **发送方:**

  - 维护一个发送窗口，大小为 N。窗口内的序号是允许发送但尚未确认的分组。
  - 发送方为**每一个**已发送但未确认的分组都维护一个**单独的定时器**。
  - 发送方发送分组时，为该分组启动定时器。
  - 接收方对每个正确接收的分组发送**独立的 ACK**。
  - 当发送方收到对序号为 n 的 ACK 报文时，它将序号为 n 的分组标记为已确认。如果序号为 n 的分组是当前窗口的 `base` 分组，并且其后的连续分组也已经被确认，发送方会将发送窗口的 `base` 移动到第一个未被确认的分组的序号。
  - **当某个分组的定时器超时时：** 发送方认为**只有这个**分组可能丢失了。发送方**只重传**这个特定的分组。

- **接收方:**

  - 维护一个接收窗口，大小通常也为 N（为了避免序号空间的歧义，发送窗口和接收窗口的大小 N 必须满足 2N≤序号空间大小）。接收窗口表示接收方愿意接受的序号范围。

  - 维护一个**接收缓存**。接收方可以接收并缓存**窗口内**的**任何**正确到达的分组，即使它不是按序到达的下一个分组。

  - 维护 `expected_seq_num`，表示接收方期望交付给上层的按序到达的下一个分组的序号（即接收窗口的下边界）。

  - 当接收方收到一个

    未损坏

    的分组：

    - 如果分组的序号**在接收窗口内** (`expected_seq_num` ≤ 序号 ≤ `expected_seq_num + N - 1`): 这是一个有效分组。将该分组放入接收缓存中。发送一个针对该分组的**独立 ACK**。
    - 如果分组的序号**小于** `expected_seq_num`：这是一个重复分组（之前已经接收并交付了）。发送针对该分组的独立 ACK（以防发送方没有收到之前的 ACK）。
    - 如果分组的序号**大于** `expected_seq_num + N - 1`：这是窗口外的高序号分组。丢弃该分组。

  - 当接收方收到一个**损坏**的分组：丢弃该分组。

  - **向上层交付数据：** 接收方检查缓存，如果序号为 `expected_seq_num` 的分组以及其后的一段连续分组都已正确收到并保存在缓存中，接收方就将这些连续的分组**按序**向上层交付，并更新 `expected_seq_num` 为下一个未交付的分组的序号，同时将接收窗口向前移动。

- **优点:** 只重传丢失或损坏的分组，减少了不必要的重传，在丢包率高的信道上效率更高。

- **缺点:** 接收方的逻辑更复杂，需要维护接收缓存，并为每个正确接收的分组发送独立的 ACK，还需要判断何时可以将缓存中的连续分组交付给上层。对序号空间的大小也有更严格的要求。

**总结 流水线协议：**

流水线协议通过允许同时发送多个分组来解决停-等协议的效率低下问题。GBN 和 SR 是两种主要的实现方式，它们在差错恢复策略、发送方和接收方的复杂性以及对信道特性的适应性上有所不同：

- **GBN:** 接收方简单，丢弃乱序分组，使用累计确认，超时后重传窗口内的所有分组。适用于信道丢包率较低的情况。
- **SR:** 接收方复杂，缓存乱序分组，使用独立确认，超时后只重传单个分组。适用于信道丢包率较高的情况。

实际的协议，如 TCP，通常借鉴了这两种协议的思想，形成了一种混合方式。TCP 使用累计确认（像 GBN），但通过快速重传（Fast Retransmit，基于重复 ACK 的机制）和选择确认（Selective Acknowledgment, SACK）等机制，又具备了一些 SR 的特性，尽量避免不必要的重传。

## TCP协议

好的，接着 RDT 协议的讨论，我们来看看 TCP (Transmission Control Protocol) 是如何工作的。TCP 是互联网中实际使用的、最主要的**可靠数据传输协议**之一，它运行在不可靠的 IP 协议之上。

可以把 TCP 看作是基于 RDT 3.0 和流水线协议（GBN 和 SR）思想的**更复杂、更健壮、功能更丰富**的实现。TCP 不仅要处理比特差错和丢包，还需要解决实际网络环境中的更多问题，比如：

- **可变的网络延迟：** 定时器超时值的确定。
- **网络拥塞：** 防止向网络注入过多流量导致崩溃。
- **接收方处理能力限制：** 防止发送方发送速度超过接收方处理速度。
- **全双工通信：** 数据可以在两个方向同时流动。
- **连接的建立与拆除：** 需要一个可靠的连接状态管理。
- **字节流导向：** TCP 视应用层数据为无结构的字节流，而不是独立的分组。

下面是 TCP 的主要工作原理和特性：

### **1. 连接建立 (Three-Way Handshake 三次握手)**

在数据传输之前，TCP 需要在客户端和服务器之间建立一个逻辑连接。这是一个可靠的握手过程：

- **客户端 -> 服务器 (SYN):** 客户端发送一个 SYN (Synchronize Sequence Numbers) 报文段，选择一个初始序列号 (ISN_c)。
- **服务器 -> 客户端 (SYN-ACK):** 服务器收到 SYN 后，同意建立连接，发送一个 SYN-ACK 报文段，包含自己的初始序列号 (ISN_s)，并确认客户端的 SYN 报文段（确认号为 ISN_c + 1）。
- **客户端 -> 服务器 (ACK):** 客户端收到 SYN-ACK 后，发送一个 ACK 报文段，确认服务器的 SYN-ACK 报文段（确认号为 ISN_s + 1）。

握手完成后，双方都知道了对方的初始序列号，并建立了连接状态。

### **2. 数据传输**

TCP 将上层应用数据视为一个无界的**字节流**，并将其分割成块，加上 TCP 头部形成**报文段 (Segment)** 进行传输。

- **序列号 (Sequence Number):** TCP 的序列号不是基于报文段的，而是基于**字节流**的。一个报文段的序列号是该报文段中**第一个字节**在整个字节流中的编号。这与 RDT 中基于分组的序号不同。

- **确认号 (Acknowledgment Number):** TCP 使用**累计确认** (Cumulative ACK)，类似于 GBN。ACK 报文段中的确认号是发送方期望接收的**下一个字节的序列号**。例如，如果主机 A 收到主机 B 发来的包含从字节 0 到 999 的数据报文段，它会发送一个 ACK 报文段，确认号为 1000，表示它已经收到了所有从字节 0 到 999 的数据，并期望接收从字节 1000 开始的数据。

- **流水线机制和窗口 (Pipelining and Window):** TCP 使用流水线机制，允许发送方在收到确认之前发送多个报文段。发送方维护一个发送窗口，其大小是动态变化的（受**拥塞控制窗口 Congestion Window, cwnd** 和**接收方窗口 Receiver Window, rwnd** 的限制）。

- **定时器 (Timer):** TCP 为每个已发送但尚未确认的报文段设置定时器。与 RDT 3.0 的固定定时器不同，TCP 的定时器是**动态调整**的。它根据测量的报文段往返时间 (RTT) 来估计合适的超时时间 (Timeout Interval)，通常使用 EWMA (Exponential Weighted Moving Average) 算法来平滑 RTT 测量值。

- TCP 通过测量报文段的 SampleRTT（样本 RTT）来估计网络的 RTT，并利用这个估计值来设置 `TimeoutInterval`。

   1. **SampleRTT (样本 RTT):**
      - **定义：** 这是 TCP 实际测量到的一个报文段的往返时间。它从发送一个报文段（非重传的）的时刻开始计时，到收到该报文段的 ACK 报文时结束计时。
      - **测量：** TCP 每次只会测量一个未重传的报文段的 SampleRTT，并且在任何时刻只会测量一个 SampleRTT，以避免歧义（即无法判断 ACK 对应的是原始发送的报文段还是重传的报文段，这就是 Karn's Algorithm Karn 定理）。
      - **作用：** 用于计算 EstimatedRTT 和 DevRTT。
   2. **EstimatedRTT (估计的 RTT):**
      - **定义：** 这是 TCP 对 SampleRTT 的平滑平均估计值。它是一个加权平均，越新的 SampleRTT 占的权重越大。
      - **作用：** 用于反映网络 RTT 的平均水平。
      - **计算：** 使用**指数加权移动平均 (EWMA)** 来计算。每次获得新的 SampleRTT 后，更新 EstimatedRTT： `EstimatedRTT = (1 - α) * EstimatedRTT + α * SampleRTT` 其中，`α` 是一个平滑因子，通常取 **0.125 (即 1/8)**。这意味着新的 SampleRTT 占 1/8 的权重，旧的 EstimatedRTT 占 7/8 的权重。
   3. **DevRTT (RTT 的偏差估计):**
      - **定义：** 这是对 SampleRTT 与 EstimatedRTT 之间偏差的平滑平均估计值。它衡量了 SampleRTT 围绕 EstimatedRTT 的波动程度。
      - **作用：** 用于衡量网络 RTT 的不确定性或波动性。波动越大，DevRTT 越大。
      - **计算：** 也使用 EWMA。每次获得新的 SampleRTT 后，更新 DevRTT： `DevRTT = (1 - β) * DevRTT + β * |SampleRTT - EstimatedRTT|` 其中，`β` 是另一个平滑因子，通常取 **0.25 (即 1/4)**。`|SampleRTT - EstimatedRTT|` 是最新的测量值与当前平均估计值之间的绝对偏差。
   4. **TimeoutInterval (重传超时时间):**
      - **定义：** 这是 TCP 发送方等待一个报文段的 ACK 的最长时间。如果在这个时间内没有收到确认，就认为报文段丢失并进行重传。
      - **作用：** 设置重传定时器的值。
      - **计算：** TimeoutInterval 是基于 EstimatedRTT 和 DevRTT 计算的。它应该略大于 EstimatedRTT，留出一定的安全裕度来应对 RTT 的波动。这个裕度就是 DevRTT 的某个倍数。 `TimeoutInterval = EstimatedRTT + 4 * DevRTT` 这个公式的直观理解是：将超时时间设为估计的平均 RTT 加上一个基于 RTT 波动程度的安全边际。因子 4 是经验值，大致可以保证在 RTT 波动符合某种统计分布时，绝大多数 SampleRTT 会落在 [EstimatedRTT - 4*DevRTT, EstimatedRTT + 4*DevRTT] 这个范围内，从而减少不必要的超时。

- 重传 (Retransmission):

   TCP 的重传由两个事件触发：

  - **超时 (Timeout):** 某个报文段的定时器超时时，发送方重传该报文段。
  - **重复 ACK (Duplicate ACKs) 与快速重传 (Fast Retransmit):** 如果发送方收到**三个**对同一个序号的重复 ACK，它认为紧随该确认号之后的报文段很可能已经丢失（因为后续报文段的确认都到了，只有这个没到），于是立即**重传这个丢失的报文段**，而无需等待定时器超时。这是 TCP 从 GBN 演进出来的一个重要优化，提供了类似 SR 的快速恢复能力。

- **选择确认 (Selective Acknowledgments, SACK):** 现代 TCP 实现通常支持 SACK 选项。通过 SACK，接收方可以在 ACK 报文段中明确告知发送方它已经收到的**不连续的数据块**的序列号范围。这使得发送方能够更精确地知道哪些报文段丢失了，从而只选择性地重传那些真正丢失的报文段（更像 SR 的行为），提高了在高丢包率环境下的性能。

### **3. 流量控制 (Flow Control)**

TCP 提供端到端的流量控制，防止发送方发送数据过快，导致接收方缓冲区溢出。

- **接收窗口 (Receiver Window, rwnd):** 接收方在其发送的 ACK 报文段中包含一个字段，告知发送方它当前还有多少可用的缓冲区空间。
- 发送方维护一个有效的发送窗口大小，等于其拥塞窗口 (cwnd) 和接收窗口 (rwnd) 中的较小值。发送方发送的数据量不能超过这个有效窗口大小。

### **4. 拥塞控制 (Congestion Control)**

这是 TCP 的一个核心且复杂的部分，旨在避免网络拥塞，公平地分享网络带宽。TCP 发送方维护一个**拥塞窗口 (cwnd)**，并根据对网络拥塞的感知来调整其大小。拥塞的感知通常通过丢包（超时或收到重复 ACK）来判断。主要的拥塞控制算法（如 TCP Tahoe, Reno, NewReno, CUBIC 等）包含几个阶段：

- **慢启动 (Slow Start):** 连接刚建立时，cwnd 从一个较小的值开始，收到一个 ACK 就指数级地增加 cwnd。
- **拥塞避免 (Congestion Avoidance):** 当 cwnd 达到一个阈值后，每收到一个窗口的 ACK，cwnd 线性增加一个固定的量。
- **快速重传/快速恢复 (Fast Retransmit / Fast Recovery):** 收到重复 ACK 时触发，通常会减小 cwnd 并进入快速恢复阶段，尝试快速恢复传输。
- **超时 (Timeout):** 定时器超时表明发生了更严重的丢包（可能网络已拥塞），cwnd 会被大幅减小，并重新进入慢启动阶段。

### **5. 连接拆除 (Four-Way Handshake 四次挥手)**

当应用层数据传输完毕后，需要可靠地关闭连接。这是一个四步过程：

- **一端 (如客户端) -> 另一端 (FIN):** 希望关闭连接的一方发送一个 FIN (Finish) 报文段。
- **另一端 -> 发送 FIN 的一端 (ACK):** 另一端收到 FIN 后，发送一个 ACK 确认该 FIN。此时连接处于半关闭状态，另一端仍然可以向发送 FIN 的一端发送数据。
- **另一端 -> 发送 FIN 的一端 (FIN):** 当另一端也没有数据要发送时，也发送一个 FIN 报文段。
- **发送 FIN 的一端 -> 另一端 (ACK):** 最初发送 FIN 的一端收到对方的 FIN 后，发送一个 ACK 确认该 FIN。在等待一个计时器（通常是 2MSL，Maximum Segment Lifetime）后，连接最终关闭。

### **TCP 与 RDT 模型的对比总结：**

- **可靠性:** TCP 实现了 RDT 的核心目标——在不可靠信道上实现可靠传输（无差错、不丢包、按序）。
- **底层信道:** TCP 运行在 IP (不可靠、尽力而为、可能丢包、乱序、损坏) 之上，比 RDT 2.x/3.0 假设的信道更接近真实。
- **差错检测:** 都使用校验和。
- **序号和确认:** TCP 使用基于字节流的序号和累计确认（类似 GBN），并结合重复 ACK 和 SACK 进行优化（借鉴 SR）。RDT 使用基于分组的序号。
- **流水线:** TCP 采用流水线，发送窗口动态变化（受流量和拥塞控制）。RDT 3.0 是停等，GBN/SR 是固定窗口。
- **定时器和重传:** TCP 使用动态定时器和超时，并结合快速重传机制。RDT 3.0 使用静态定时器。
- **错误恢复:** TCP 的恢复机制更复杂，结合超时、快速重传、SACK 等，试图更高效地只重传丢失的报文段。GBN 重传整个窗口，SR 选择重传（理论模型）。
- **其他功能:** TCP 增加了 RDT 缺乏的连接管理、流量控制、拥塞控制和全双工通信等重要功能。

总的来说，TCP 是一个功能强大、复杂且经过长期优化的协议，它将 RDT 协议中的基本可靠性机制与应对真实网络挑战（如拥塞、流量控制、动态延迟）的技术相结合，是构建现代互联网应用基石。

# Chapter 4 网络层：数据平面

# Chapter 5 网络层：控制层面
